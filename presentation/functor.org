#+OPTIONS: toc:nil
#+REVEAL_HLEVEL: 2
*  Functor
** Type class review.

   Type class as a parameterised trait
   #+begin_src scala
     trait JsonWriter[A] {
       def write(value: A): Json
     }
   #+end_src

   #+REVEAL: split:t
   Instance of the type class
   #+begin_src scala
     object JsonWriterInstances {
       implicit val stringWriter: JsonWriter[String] =
         new JsonWriter[String] {
           def write(value: String): Json =
             JsString(value)
         }
     }
   #+end_src


   #+REVEAL: split:t

   Interface object
   #+begin_src scala

     object Json {
       def toJson[A](value: A)(implicit w: JsonWriter[A]): Json =
         w.write(value)
     }

   #+end_src

   Usage
   #+begin_src scala
     Json.toJson("foo bar")
   #+end_src

   #+REVEAL: split:t

   Interface syntax
   #+begin_src scala
     implicit class JsonWriterOps[A](value: A) {
       def toJson(implicit w: JsonWriter[A]): Json =
         w.write(value)
     }
   #+end_src

   Usage
   #+begin_src scala
     "foo bar".toJson
     1.toJson
     Person("John", "Smith").toJson
   #+end_src


** Monoid review

   #+begin_src scala

     trait Monoid[A] {
       def combine(x: A, y: A): A
       def empty: A
     }
   #+end_src

   #+REVEAL: split:t
   #+begin_src scala
     object MonoidLaws {

       // (1 + 2) + 3 == 1 + (2 + 3)
       def associativeLaw[A](x: A, y: A, z: A)(implicit m: Monoid[A]): Boolean = {
         m.combine(x, m.combine(y, z)) ==
         m.combine(m.combine(x, y), z)
       }

       // 2 + 0 == 0 + 2 == 2
       def identityLaw[A](x: A)(implicit m: Monoid[A]): Boolean = {
         (m.combine(x, m.empty) == x) &&
         (m.combine(m.empty, x) == x)
       }
     }

   #+end_src


**   Functor
*** Informal definition
    #+ATTR_REVEAL: :frag roll-in
    Functor is anything with a map method.

    #+ATTR_REVEAL: :frag roll-in
    #+begin_src scala
      trait Functor[F[_]] {
        def map[A, B](fa: F[A])(f: A => B): F[B]
      }
    #+end_src

    #+ATTR_REVEAL: :frag roll-in
    /Compare type paremeter to Monoid type class./
    #+ATTR_REVEAL: :frag roll-in
    #+begin_src scala
      trait Monoid[A] {
        def combine(x: A, y: A): A
        def empty: A
      }

    #+end_src

*** Type constructors

    #+begin_src
 scala> :k Int
 Int's kind is A

 scala> :k List
 List's kind is F[+A]

 scala> :k Option
 Option's kind is F[+A]

 scala> :k Either
 Either's kind is F[+A1,+A2]

 scala> :k Future
 scala.concurrent.Future's kind is F[+A]
    #+end_src

*** Examples of Functors
    #+begin_src

scala> List(1,2,4).map(n => n + 10)
val res1: List[Int] = List(11, 12, 14)

scala>
    #+end_src
